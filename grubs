#!/bin/bash
set -eu

# Copyright (c) 2014 Daniel Wayne Armstrong. All rights reserved.
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License (GPLv2) published by
# the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the LICENSE file for more details.

# NOTES
# * GRUBS Reanimated USB Boot Stick
#   http://www.circuidipity.com/grubs.html>

# Script variables
script_name="GRUBS"
script_command="grubs"
script_description="GRUBS Reanimated USB Boot Stick"
script_synopsis="$script_command DEVICE"
script_src="https://github.com/vonbrownie/grubs/blob/master/grubs"
script_depends="grub2-common, dosfstools, rsync"
script_device="${@: -1}"
## -------------- MODIFY -------------- ##
## Location of Linux iso images
iso_dir="$HOME/grubs/iso"
## GRUB grub_conf for the USB stick
grub_conf="$HOME/grubs/grub.cfg"
## ------------------------------------ ##

# Functions
penguinista() {
cat << _EOF_

(O<
(/)_
_EOF_
}

script_options() {
cat << _EOF_

OPTIONS
  -h    print command syntax and options
_EOF_
}

full_script_description() {
cat << _EOF_

$( penguinista ) .: $script_name -- $script_description

SYNOPSIS
  $script_synopsis
EXAMPLE
  Prepare a USB stick partition identified as /dev/sdb1:
  $ sudo $script_command sdb1
_EOF_
script_options
}

run_options() {
while getopts ":h" OPT
do
    case $OPT in
        h)
            full_script_description
            exit
            ;;
        ?)
            echo "$( penguinista ) .: Invalid option '-$OPTARG'\n"
            script_options
            exit 1
            ;;
    esac
done
}

greeting() {
cat << _EOF_

Howdy! '$script_name' transforms a standard USB stick into a dual-purpose script_device that
is both a storage medium usable under Linux, Windows, and Mac OS and a GRUB
boot script_device packing multiple Linux distros.

See: "Transform a USB stick into a boot script_device packing multiple Linux distros"
http://www.circuidipity.com/multi-boot-usb.html

### WARNING ###
Make careful note of the drive and partition labels on your system!

You have chosen '$script_device' as script_device.

The INSTALL option will **destroy all data** currently stored on $script_device.

This script should be run with ROOT privileges. Please check it before use in
a text editor and make any required modifications.

_EOF_
}

invalid_reply() {
printf "\n'$REPLY' is invalid input ...\n"
}

invalid_reply_yn() {
printf "\n'$REPLY' is invalid input. Please select 'Y(es)' or 'N(o)' ...\n"
}

confirm_start() {
while :
do
    read -n 1 -p "Run script now? [yN] > "
    if [[ $REPLY == [yY] ]]
    then
        printf "\nLet's roll then ...\n"
        break
    elif [[ $REPLY == [nN] || $REPLY == "" ]]
    then
        penguinista
        exit
    else
        invalid_reply_yn
    fi
done
}

hello_world() {
full_script_description
greeting
confirm_start
}

test_root() {
if [[ $UID -ne 0 ]]
then
    printf \
        "\n$( penguinista ) .: $script_name requires ROOT privileges to do its job.\n"
    exit 1
fi
}

test_script_device() {
if [[ -z $script_device ]]
then
    echo "$( penguinista ) .: $script_name requires the DEVICE argument.\n"
    exit 1
fi
if [[ ! -b /dev/$script_device ]] || [[ ! $script_device == sd[b-z]1 ]]
then
    printf "\n$( penguinista ) .: '$script_device' not available for use.\n"
    printf "script_device argument must be a 'sd[b-z]1' string.\n"
    exit 1
fi
}

test_variable() {
if [[ ! -d $iso_dir ]]
then
    printf "\n$( penguinista ) .: '$iso_dir' not a valid location.\n"
    printf "Please open $script_name in a text editor and modify variable iso_dir.\n"
    exit 1
fi
if [[ ! -e $grub_conf ]]
then
    printf "\n$( penguinista ) .: '$grub_conf' not a valid file.\n"
    printf "Please open $script_name in a text editor and modify variable grub_conf.\n"
    exit 1
fi
}

test_mount() {
## A test to ensure that our modification are
## going to '/MOUNTPOINT/boot' NOT '/boot'
local MNT
MNT=$(mount | grep $script_device | awk '{print $3}')
if [[ "$MNT/boot" == "/boot" ]]
then
    printf \
        "\n$( penguinista ) .: DESTINATION is the root directory... Abort!\n"
    exit 1
fi
}

test_condition() {
test_root
test_script_device
test_variable
}

mountdir() {
local MULTIMNT
MULTIMNT="/mnt"
if ! $(mount | grep /dev/$script_device >/dev/null)
then
    if $(mount | grep $MULTIMNT >/dev/null)
    then
        printf "\n$( penguinista ) .: '/mnt' is not available for use.\n"
        printf "Please unmount any script_devices attached to /mnt and re-run $script_name\n"
        exit 1
    else
        printf "\nOK. Mounting /dev/$script_device to $MULTIMNT ...\n"
        mount -t vfat /dev/$script_device $MULTIMNT
    fi
fi
}

umountdir() {
if $(mount | grep /dev/$script_device >/dev/null)
then
    printf "\nOK. Unmounting /dev/$script_device ...\n"
    umount /dev/$script_device
fi
}

createdir() {
mountdir
test_mount
local MNT
MNT=$(mount | grep $script_device | awk '{print $3}')
printf "\nCreating BOOT and ISO folders ...\n"
mkdir $MNT/{boot,iso}
printf "\n"
}

create_filesystem() {
while :
do
read -n 1 -p \
    "### WARNING ### All data will be wiped from $script_device! Proceed? [yN] > "
if [[ $REPLY == [yY] ]]
then
    umountdir
    printf "\nCreating FAT32 filesystem on $script_device ...\n"
    mkfs.vfat -n multiboot /dev/$script_device
    printf "\n"
    break
elif [[ $REPLY == [nN] || $REPLY == "" ]]
then
    printf "\nAbort install.\n"
    penguinista
    exit
else
    invalid_reply_yn
fi
done
}

grub_mbr() {
local MNT
MNT=$(mount | grep $script_device | awk '{print $3}')
# Install GRUB to the Master Boot Record (MBR) of the USB script_device
printf "\nInstalling GRUB to MBR of ${script_device:0:3} ...\n"
grub-install --force --no-floppy --boot-directory=$MNT/boot /dev/${script_device:0:3}
printf "\n"
}

grub_cfg() {
mountdir
test_mount
local MNT
MNT=$(mount | grep $script_device | awk '{print $3}')
local Ggrub_conf
Ggrub_conf="$MNT/boot/grub/grub.cfg"
printf "\nCopying grub.cfg ...\n"
if [[ -e "$Ggrub_conf" ]]
then
    cp $Ggrub_conf ${Ggrub_conf}.$(date +%Y-%m-%dT%H%M%S).bak
fi
cp $grub_conf $Ggrub_conf
printf "\n"
}

linux_iso() {
local MNT
MNT=$(mount | grep $script_device | awk '{print $3}')
printf "\nCopying Linux *.iso files ...\n"
## See http://rsync.samba.org/FAQ.html#2 about using the "--modify-window=1"
## option to better manage modification times when using rsync between Linux
## and FAT32 filesystems
rsync --recursive --update --delete --progress --modify-window=1 \
    --include '*iso' --exclude '*' $iso_dir/ $MNT/iso/
# Copy memtest<VERSION>.bin
cp $iso_dir/*.bin $MNT/boot/
sleep 15
printf "\n"
}

boot_update() {
## Copy grub.cfg
grub_cfg
## Copy Linux distros
linux_iso
}

boot_create() {
## Format script_device
create_filesystem
## Create BOOT + ISO
createdir
## Install GRUB
grub_mbr
## Update grub_conf + ISO
boot_update
}

create_vs_update() {
while :
do
cat << _EOF_

Please make a selection:

0) INSTALL multiple Linux distros and GRUB on $script_device 
1) UPDATE the Linux distros and GRUB grub_conf on $script_device

_EOF_
read -n 1 -p "Your choice? [0-1] > "

case $REPLY in
    0)	printf "\nOK. grub_confuring $script_device ...\n"
	boot_create
	break
	;;      
    1)	printf "\nOK. Updating $script_device ...\n"
	boot_update
	break
	;;
    *)  invalid_reply
	;;
esac
done
}

all_done() {
cat << _EOF_
All done!

_EOF_
penguinista
}

##: START
run_options "$@"
hello_world
test_condition

##: grub_confURE
create_vs_update

##: AU REVOIR
all_done
